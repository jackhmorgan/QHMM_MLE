'''
Copyright 2025 Jack Morgan

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
'''

from HMM.utils.qhmm_utils import result_getter
from qiskit.quantum_info.operators.operator import Operator
import numpy as np
from qiskit_aer import AerSimulator
from qiskit import transpile, QuantumCircuit

# This class `aer_simulator_result_getter` uses the AerSimulator to generate sequences and calculate
# log-likelihood for quantum circuits.
class statevector_result_getter(result_getter):
    def __init__(self,
              ):       
        self.simulator = AerSimulator()
        self.save_state = True


    def generate_sequence(self, 
                          circuit : QuantumCircuit):
        """
        This function generates a sequence of integers based on the measurement outcomes of a quantum
        circuit generated by a QHMM, executed on the AerSimulator.
        
        :param circuit: The `generate_sequence` method takes a QuantumCircuit object named `circuit` as
        input.
        :type circuit: QuantumCircuit
        :return: The function `generate_sequence` returns a list of integers representing the
        measurement outcomes of a quantum circuit run on a quantum simulator.
        """
        super().generate_sequence()
        transpiled = transpile(circuits=circuit, backend=self.simulator)
        result = self.simulator.run(transpiled, shots=1).result()
        sequence = [int(binary, 2) for binary in next(iter(result.get_counts())).split()]
        return sequence
    
    def log_likelihood(self, 
                       circuit : QuantumCircuit, 
                       sequence : list[int]):
        """
        This function calculates the log likelihood of observing a given sequence of outcomes from a
        quantum circuit simulation. This method is called by the QHMM.log_likelihood() method.
        
        :param circuit: The `circuit` parameter in the `log_likelihood` function is a QuantumCircuit
        created by the QHMM log_likelihood method
        :type circuit: QuantumCircuit
        :param sequence: The `sequence` parameter in the `log_likelihood` function is a list of integers
        representing the observed outcomes at each step of the quantum circuit execution. This method determines
        the likelihood of the sequence being observed by the model.
        :type sequence: list[int]
        :return: The `log_likelihood` function returns the log likelihood value calculated based on the
        given quantum circuit and observation sequence. If the likelihood value is 0, it returns
        negative infinity, otherwise, it returns the natural logarithm of the likelihood value.
        """

        transpiled = transpile(circuit, backend=self.simulator)
        #params = circuit.parameters
        bound_ansatz = circuit.data[2].operation #self.ansatz.assign_parameters(params)
        result = self.simulator.run(transpiled).result()
        likelihood = 1
        observed_qargs = [i for i in range(circuit.qregs[0].size, circuit.num_qubits)]
        for step, sample in enumerate(sequence):
            if step==0:
                sv = result.data()['step_'+str(step)]

            probs = sv.probabilities(observed_qargs)
            likelihood *= probs[sample]
            if likelihood == 0:
                break
            
            proj = np.zeros(len(probs), dtype=complex)
            proj[sample] = 1 / np.sqrt(probs[sample])
            sv = sv.evolve(Operator(np.diag(proj), input_dims=sv.dims(observed_qargs), output_dims=sv.dims(observed_qargs)), qargs=observed_qargs)
            sv = sv.evolve(bound_ansatz)

        if likelihood == 0:
            return float('-inf')
        else:
            return float(np.log(likelihood))